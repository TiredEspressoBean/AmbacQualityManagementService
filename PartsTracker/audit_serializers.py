"""
Serializer Field Audit Tool

Identifies model fields missing from serializers, filtering out intentional omissions.
Outputs actionable gaps grouped by priority.

Usage:
    python audit_serializers.py [--verbose] [--category CATEGORY]

Examples:
    python audit_serializers.py                    # Standard audit
    python audit_serializers.py --verbose          # Include backend-only reasoning
    python audit_serializers.py --category itar    # Only ITAR fields
"""
import os
import sys
import argparse
import django

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'PartsTrackerApp.settings')
django.setup()

from django.apps import apps
from django.db.models.fields.related import ForeignKey, OneToOneField, ManyToManyField
from rest_framework import serializers
import importlib
import inspect
from collections import defaultdict


# =============================================================================
# CONFIGURATION
# =============================================================================

SERIALIZER_MODULES = [
    'Tracker.serializers.core',
    'Tracker.serializers.mes_lite',
    'Tracker.serializers.mes_standard',
    'Tracker.serializers.qms',
    'Tracker.serializers.dms',
    'Tracker.serializers.reman',
]

# Fields that should NEVER be exposed in API
ALWAYS_EXCLUDE = {
    # Identity / tenant
    'id', 'pk', 'tenant', 'tenant_id',
    # Versioning - handled at model/queryset layer
    'external_id', 'version', 'is_current_version', 'previous_version',
    # Soft delete - filtered by queryset
    'deleted_at', 'archived',
    # Timestamps - often omitted from lightweight serializers intentionally
    'created_at', 'updated_at',
    # Auth security
    'password', 'logentry', 'is_superuser', 'last_login', 'date_joined',
    'groups', 'user_permissions',
}

# Serializers intentionally kept lightweight (dropdowns, selects, etc.)
LIGHTWEIGHT_SERIALIZERS = {
    'PartSelectSerializer',
    'PartTypeSelectSerializer',
    'UserSelectSerializer',
    'EmployeeSelectSerializer',
    'CustomerSerializer',
    'WorkCenterSelectSerializer',
    'StepAdvancementSerializer',
    'IncrementStepSerializer',
    'CustomerPartsSerializer',
}

# Fields with specific backend-only reasons
BACKEND_ONLY = {
    'token': 'Security: never expose tokens',
    'hubspot_last_synced_at': 'Internal sync state',
    'last_synced_hubspot_stage': 'Internal sync state',
    'notification_sent': 'Internal state',
    'notification_sent_at': 'Internal state',
    '_requires_calibration_override': 'Internal override (underscore prefix)',
    'content_object': 'GenericFK - needs custom handling',
    'related_object': 'GenericFK - needs custom handling',
    'related_object_id': 'GenericFK component',
    'related_content_type': 'GenericFK component',
}

# Field categorization for prioritization
FIELD_CATEGORIES = {
    'itar': {
        'itar_controlled', 'eccn', 'usml_category', 'export_control_reason',
        'export_license_required', 'country_of_origin', 'us_person',
        'eu_authorized', 'uk_authorized', 'citizenship',
        'export_control_verified', 'export_control_verified_at',
        'export_control_verified_by', 'export_control_notes',
    },
    'dms': {
        'effective_date', 'review_date', 'obsolete_date', 'retention_until',
        'approved_by', 'approved_at',
    },
    'equipment': {
        'calibration_due', 'calibration_interval_days', 'last_calibration',
        'next_calibration', 'serial_number', 'manufacturer', 'model_number',
        'location',
    },
    'hubspot': {
        'hubspot_deal_id', 'current_hubspot_gate',
    },
}

# Reverse relation types (auto-generated by Django, not direct fields)
REVERSE_RELATION_TYPES = (
    'ManyToOneRel',
    'ManyToManyRel',
    'OneToOneRel',
    'GenericRelation',
)


# =============================================================================
# HELPERS
# =============================================================================

def is_direct_field(field):
    """Check if field is a direct model field (not reverse relation)."""
    return type(field).__name__ not in REVERSE_RELATION_TYPES


def categorize_field(field_name, field):
    """Assign category to a field for prioritization."""
    for category, field_set in FIELD_CATEGORIES.items():
        if field_name in field_set:
            return category

    if field_name == 'status':
        return 'status'
    if isinstance(field, ManyToManyField):
        return 'm2m'
    if isinstance(field, (ForeignKey, OneToOneField)):
        return 'fk'
    return 'business'


def should_add_field(field_name, field, serializer_name):
    """
    Determine if a missing field should be added to the serializer.
    Returns (should_add: bool, reason: str)
    """
    # Always exclude
    if field_name in ALWAYS_EXCLUDE:
        return False, 'Always excluded (versioning/auth/timestamps)'

    # Specific backend-only reasons
    if field_name in BACKEND_ONLY:
        return False, BACKEND_ONLY[field_name]

    # Lightweight serializers - only flag important fields
    if serializer_name in LIGHTWEIGHT_SERIALIZERS:
        # Important even in lightweight
        important = {'status', 'order_number', 'report_number', 'user_type', 'is_active'}
        if field_name in important:
            return True, 'Important field missing from lightweight serializer'

        # ITAR not needed in dropdowns
        if field_name in FIELD_CATEGORIES['itar']:
            return False, 'ITAR not needed in lightweight/select serializers'

        # Detail fields not needed
        return False, 'Detail field not needed in lightweight serializer'

    # M2M usually separate endpoints
    if isinstance(field, ManyToManyField):
        return False, 'M2M - typically fetched via separate endpoint'

    # Versioning FKs
    if isinstance(field, (ForeignKey, OneToOneField)):
        if 'previous' in field_name or 'supersede' in field_name:
            return False, 'Versioning FK'

    return True, 'Should be added'


def get_serializer_fields(serializer_class):
    """Extract all field names from a serializer."""
    fields = set()

    if hasattr(serializer_class, 'Meta') and hasattr(serializer_class.Meta, 'fields'):
        meta_fields = serializer_class.Meta.fields
        if meta_fields == '__all__':
            return {'__all__'}
        fields.update(meta_fields)

    for name, field in serializer_class._declared_fields.items():
        fields.add(name)
        if hasattr(field, 'source') and field.source:
            fields.add(field.source.split('.')[0])

    return fields


def get_direct_model_fields(model):
    """Get direct (non-reverse) fields from a model."""
    fields = {}
    for field in model._meta.get_fields():
        if is_direct_field(field):
            fields[field.name] = field
    return fields


def collect_serializers():
    """Import and collect all serializers from configured modules."""
    all_serializers = {}

    for module_name in SERIALIZER_MODULES:
        try:
            module = importlib.import_module(module_name)
            for name, obj in inspect.getmembers(module):
                if (inspect.isclass(obj) and
                    issubclass(obj, serializers.ModelSerializer) and
                    obj != serializers.ModelSerializer and
                    hasattr(obj, 'Meta') and
                    hasattr(obj.Meta, 'model')):

                    model = obj.Meta.model
                    model_name = f"{model._meta.app_label}.{model._meta.model_name}"

                    if model_name not in all_serializers:
                        all_serializers[model_name] = []
                    all_serializers[model_name].append((name, obj))
        except ImportError as e:
            print(f"Warning: Could not import {module_name}: {e}", file=sys.stderr)

    return all_serializers


# =============================================================================
# MAIN AUDIT
# =============================================================================

def run_audit(verbose=False, category_filter=None):
    """Run the serializer field audit."""

    all_serializers = collect_serializers()
    tracker_models = apps.get_app_config('Tracker').get_models()

    should_add = []
    should_stay = defaultdict(list)

    for model in tracker_models:
        model_name = f"{model._meta.app_label}.{model._meta.model_name}"
        direct_fields = get_direct_model_fields(model)

        if model_name not in all_serializers:
            continue

        for serializer_name, serializer_class in all_serializers[model_name]:
            serializer_fields = get_serializer_fields(serializer_class)

            if '__all__' in serializer_fields:
                continue

            missing = set(direct_fields.keys()) - serializer_fields

            for field_name in missing:
                field = direct_fields[field_name]
                category = categorize_field(field_name, field)

                # Apply category filter if specified
                if category_filter and category != category_filter:
                    continue

                add, reason = should_add_field(field_name, field, serializer_name)

                entry = {
                    'model': model_name,
                    'serializer': serializer_name,
                    'field': field_name,
                    'category': category,
                    'reason': reason,
                }

                if add:
                    should_add.append(entry)
                else:
                    should_stay[reason].append(entry)

    # Output results
    print("=" * 80)
    print("SERIALIZER FIELD AUDIT")
    print("=" * 80)

    print(f"\n  Fields to ADD: {len(should_add)}")
    print(f"  Fields OK as-is: {sum(len(v) for v in should_stay.values())}")

    if should_add:
        print("\n" + "=" * 80)
        print("FIELDS TO ADD")
        print("=" * 80)

        # Group by category then serializer
        by_category = defaultdict(lambda: defaultdict(list))
        for entry in should_add:
            key = f"{entry['model']} -> {entry['serializer']}"
            by_category[entry['category']][key].append(entry['field'])

        # Priority order
        category_order = ['itar', 'dms', 'equipment', 'status', 'business', 'hubspot', 'fk']

        for category in category_order:
            if category not in by_category:
                continue

            print(f"\n[{category.upper()}]")
            for serializer_key, fields in sorted(by_category[category].items()):
                print(f"  {serializer_key}")
                print(f"    -> {', '.join(sorted(fields))}")

    if verbose and should_stay:
        print("\n" + "=" * 80)
        print("FIELDS STAYING BACKEND (by reason)")
        print("=" * 80)

        for reason, entries in sorted(should_stay.items(), key=lambda x: -len(x[1])):
            print(f"\n{reason}: {len(entries)}")

    print("\n" + "=" * 80)
    print("AUDIT COMPLETE")
    print("=" * 80)

    return len(should_add)


# =============================================================================
# CLI
# =============================================================================

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Audit serializer fields')
    parser.add_argument('--verbose', '-v', action='store_true',
                        help='Show backend-only field reasoning')
    parser.add_argument('--category', '-c', type=str,
                        choices=['itar', 'dms', 'equipment', 'status', 'business', 'hubspot', 'fk', 'm2m'],
                        help='Filter to specific category')

    args = parser.parse_args()

    count = run_audit(verbose=args.verbose, category_filter=args.category)
    sys.exit(0 if count == 0 else 1)
