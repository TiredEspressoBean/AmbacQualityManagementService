import { useState, useEffect, useCallback } from 'react';
import { type Node, type Edge, useReactFlow, useNodesInitialized } from '@xyflow/react';
import ELK, { type ElkNode, type ElkExtendedEdge } from 'elkjs/lib/elk.bundled.js';

export type StepType = 'task' | 'start' | 'decision' | 'rework' | 'timer' | 'terminal';

/**
 * Step data with order (for use in flow builder).
 * Order comes from ProcessStep, not the Step model itself.
 */
export interface StepData {
  id: string;
  name: string;
  order: number; // From ProcessStep.order
  step_type?: StepType;
  is_decision_point?: boolean;
  decision_type?: 'qa_result' | 'measurement' | 'manual';
  is_terminal?: boolean;
  terminal_status?: 'completed' | 'shipped' | 'stock' | 'scrapped' | 'returned' | 'awaiting_pickup' | 'core_banked' | 'rma_closed';
  is_entry_point?: boolean;
  description?: string;
  max_visits?: number | null;
  expected_duration?: string | null;
  // QA settings
  requires_qa_signoff?: boolean;
  sampling_required?: boolean;
  min_sampling_rate?: number;
}

/**
 * Edge data for step routing.
 */
export interface StepEdgeInput {
  from_step: string;
  to_step: string;
  edge_type: 'default' | 'alternate' | 'escalation';
}

export interface UseStepsToFlowOptions {
  /** Direction: 'RIGHT', 'DOWN', 'LEFT', 'UP' */
  direction?: 'RIGHT' | 'DOWN' | 'LEFT' | 'UP';
  /** Spacing between nodes */
  nodeSpacing?: number;
  /** Spacing between layers/ranks */
  layerSpacing?: number;
}

// Create ELK instance once
const elk = new ELK();

/**
 * Determine the node type for a step.
 * Uses explicit step_type if set, otherwise derives from properties.
 */
function getNodeType(step: StepData, isEntryPoint: boolean): StepType {
  // Use explicit step_type if set (and not default 'task')
  if (step.step_type && step.step_type !== 'task') {
    return step.step_type;
  }

  // Derive from properties
  // Terminal nodes (end points)
  if (step.is_terminal) return 'terminal';

  // Decision nodes (branching points)
  if (step.is_decision_point) return 'decision';

  // Start node (entry point or no incoming edges)
  if (isEntryPoint) return 'start';

  // Rework nodes (have max_visits set)
  if (step.max_visits) return 'rework';

  // Timer nodes (have expected_duration set)
  if (step.expected_duration) return 'timer';

  // Default to task
  return 'task';
}

/**
 * Build initial nodes and edges from steps data.
 * Nodes start at (0,0) - positions will be set after measurement.
 *
 * @param steps - Array of steps with order (from ProcessStep)
 * @param stepEdges - Optional array of edges (from StepEdge). If not provided, edges are auto-generated by order.
 */
export function buildNodesAndEdges(steps: StepData[], stepEdges?: StepEdgeInput[]) {
  if (!steps || steps.length === 0) {
    return { nodes: [], edges: [] };
  }

  const nodes: Node[] = [];
  const edges: Edge[] = [];
  const sortedSteps = [...steps].sort((a, b) => a.order - b.order);

  // Find which steps are targets (to identify entry points if not explicitly set)
  const targetStepIds = new Set<string>();
  if (stepEdges && stepEdges.length > 0) {
    stepEdges.forEach((edge) => {
      targetStepIds.add(edge.to_step);
    });
  }

  // Create nodes - initially spread out for measurement
  sortedSteps.forEach((step, index) => {
    // A step is an entry point if explicitly marked or no edges point to it
    const isEntryPoint = step.is_entry_point || (!targetStepIds.has(step.id) && index === 0);
    const nodeType = getNodeType(step, isEntryPoint);

    nodes.push({
      id: String(step.id),
      type: nodeType,
      position: { x: index * 250, y: 0 }, // Spread out for initial render
      data: {
        label: step.name,
        step,
        isDecisionPoint: step.is_decision_point,
        decisionType: step.decision_type,
        isTerminal: step.is_terminal,
        terminalStatus: step.terminal_status,
        description: step.description,
        maxVisits: step.max_visits,
        expectedDuration: step.expected_duration,
        isStart: isEntryPoint,
        // QA settings
        requiresQaSignoff: step.requires_qa_signoff,
        samplingRequired: step.sampling_required,
        minSamplingRate: step.min_sampling_rate,
      },
    });
  });

  // Create edges from StepEdges if provided
  if (stepEdges && stepEdges.length > 0) {
    stepEdges.forEach((edge) => {
      const sourceStep = sortedSteps.find(s => s.id === edge.from_step);

      // Determine if the source node will render as a decision node with pass/fail handles
      // This must match the logic in getNodeType() to ensure consistency
      const sourceNodeType = sourceStep ? getNodeType(sourceStep, sourceStep.is_entry_point || false) : undefined;
      const isDecisionNode = sourceNodeType === 'decision';

      if (edge.edge_type === 'default') {
        edges.push({
          id: `e${edge.from_step}-${edge.to_step}`,
          source: String(edge.from_step),
          target: String(edge.to_step),
          sourceHandle: isDecisionNode ? 'pass' : undefined,
          label: isDecisionNode ? 'Pass' : undefined,
          type: 'smoothstep',
          style: { stroke: isDecisionNode ? '#10b981' : undefined },
          animated: true,
          labelStyle: isDecisionNode ? { fill: '#10b981', fontWeight: 600 } : undefined,
          labelBgStyle: { fill: 'transparent' },
        });
      } else if (edge.edge_type === 'alternate') {
        edges.push({
          id: `e${edge.from_step}-${edge.to_step}-alt`,
          source: String(edge.from_step),
          target: String(edge.to_step),
          sourceHandle: isDecisionNode ? 'fail' : undefined,
          label: 'Fail',
          type: 'smoothstep',
          style: { stroke: '#ef4444' },
          animated: true,
          labelStyle: { fill: '#ef4444', fontWeight: 600 },
          labelBgStyle: { fill: 'transparent' },
        });
      } else if (edge.edge_type === 'escalation') {
        edges.push({
          id: `e${edge.from_step}-${edge.to_step}-esc`,
          source: String(edge.from_step),
          target: String(edge.to_step),
          label: 'Max Exceeded',
          type: 'smoothstep',
          style: { stroke: '#f97316', strokeDasharray: '5,5' },
          animated: true,
          labelStyle: { fill: '#f97316', fontWeight: 600, fontSize: 11 },
          labelBgStyle: { fill: 'transparent' },
        });
      }
    });
  } else {
    // Fallback: auto-connect steps by order if no edges provided
    sortedSteps.forEach((step, index) => {
      if (index < sortedSteps.length - 1 && !step.is_terminal) {
        const nextStep = sortedSteps[index + 1];
        edges.push({
          id: `e${step.id}-${nextStep.id}`,
          source: String(step.id),
          target: String(nextStep.id),
          type: 'smoothstep',
          animated: true,
        });
      }
    });
  }

  return { nodes, edges };
}

/**
 * Run ELK layout with measured node dimensions.
 */
export async function runElkLayout(
  nodes: Node[],
  edges: Edge[],
  nodeDimensions: Map<string, { width: number; height: number }>,
  options: UseStepsToFlowOptions = {}
): Promise<Node[]> {
  const {
    direction = 'RIGHT',
    nodeSpacing = 50,
    layerSpacing = 80,
  } = options;

  if (nodes.length === 0) return [];

  const elkGraph: ElkNode = {
    id: 'root',
    layoutOptions: {
      'elk.algorithm': 'layered',
      'elk.direction': direction,
      'elk.spacing.nodeNode': String(nodeSpacing),
      'elk.layered.spacing.nodeNodeBetweenLayers': String(layerSpacing),
      'elk.layered.nodePlacement.strategy': 'BRANDES_KOEPF',
      'elk.layered.crossingMinimization.strategy': 'LAYER_SWEEP',
      'elk.edgeRouting': 'SPLINES',
      // Ensure proper layering respects edge direction
      'elk.layered.layering.strategy': 'NETWORK_SIMPLEX',
      'elk.layered.considerModelOrder.strategy': 'NODES_AND_EDGES',
    },
    children: nodes.map((node) => {
      const dims = nodeDimensions.get(node.id) || { width: 180, height: 60 };
      const layoutOptions: Record<string, string> = {};

      // Force start nodes to first layer, terminal nodes to last layer
      if (node.type === 'start') {
        layoutOptions['elk.layered.layering.layerConstraint'] = 'FIRST';
      } else if (node.type === 'terminal') {
        layoutOptions['elk.layered.layering.layerConstraint'] = 'LAST';
      }

      return {
        id: node.id,
        width: dims.width,
        height: dims.height,
        layoutOptions,
      };
    }),
    edges: edges.map((edge) => ({
      id: edge.id,
      sources: [edge.source],
      targets: [edge.target],
    })) as ElkExtendedEdge[],
  };

  const layoutedGraph = await elk.layout(elkGraph);

  return nodes.map((node) => {
    const elkNode = layoutedGraph.children?.find((n) => n.id === node.id);
    return {
      ...node,
      position: {
        x: elkNode?.x ?? 0,
        y: elkNode?.y ?? 0,
      },
    };
  });
}

/**
 * Hook to run ELK layout after nodes are measured.
 * Must be used inside ReactFlowProvider.
 */
export function useAutoLayout(options: UseStepsToFlowOptions = {}) {
  const { getNodes, getEdges, setNodes, fitView } = useReactFlow();
  const nodesInitialized = useNodesInitialized();
  const [hasLayouted, setHasLayouted] = useState(false);

  const runLayout = useCallback(async () => {
    const nodes = getNodes();
    const edges = getEdges();
    if (nodes.length === 0) return;

    // Get measured dimensions from React Flow
    const nodeDimensions = new Map<string, { width: number; height: number }>();
    nodes.forEach((node) => {
      if (node.measured?.width && node.measured?.height) {
        nodeDimensions.set(node.id, {
          width: node.measured.width,
          height: node.measured.height,
        });
      }
    });

    // Skip if no measurements yet
    if (nodeDimensions.size === 0) return;

    try {
      const layoutedNodes = await runElkLayout(nodes, edges, nodeDimensions, options);
      setNodes(layoutedNodes);
      setHasLayouted(true);

      // Fit view after layout (commented out - ReactFlow's fitView prop handles initial fit)
      // requestAnimationFrame(() => {
      //   fitView({ padding: 0.1, maxZoom: 1, duration: 200 });
      // });
    } catch (err) {
      console.error('ELK layout error:', err);
    }
  }, [getNodes, getEdges, setNodes, fitView, options]);

  // Run layout when nodes are initialized (measured)
  useEffect(() => {
    if (nodesInitialized && !hasLayouted) {
      runLayout();
    }
  }, [nodesInitialized, hasLayouted, runLayout]);

  // Reset layout flag when nodes change significantly
  const resetLayout = useCallback(() => {
    setHasLayouted(false);
  }, []);

  return { runLayout, resetLayout, hasLayouted };
}
